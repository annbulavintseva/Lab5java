# Національний технічний університет України

## "Київський політехнічний інститут імені Ігоря Сікорського"

### Булавінцева Анна ТЗ-22

Лабораторна робота №5

### 1. Порівняйте та назвіть переваги та недоліки таких методів сортування: сортування бульбашкою, сортування вибором, сортування вставкою.
Сортування бульбашкою
Переваги:
Простота реалізації.
Добре працює для майже відсортованих даних.
Не вимагає додаткової пам’яті (сортування на місці).
Недоліки:
Низька ефективність для великих наборів даних (часова складність O(n^2))
Навіть якщо список вже майже відсортований, виконує багато непотрібних операцій без оптимізацій.
Повільніше порівняно з іншими алгоритмами сортування.

Сортування вибором
Переваги:
Простота реалізації.
Завжди виконує однакову кількість операцій незалежно від початкового стану списку.
Економно використовує пам’ять (сортування на місці).
Недоліки:
Низька ефективність для великих наборів даних (часова складність O(n^2))
Не підходить для майже відсортованих даних, бо завжди виконує фіксовану кількість операцій.
Часто повільніше, ніж сортування вставкою для більшості практичних випадків.

Сортування вставкою
Переваги:
Ефективне для невеликих масивів або майже відсортованих даних (часова складність у найкращому випадку O(n))
Простота реалізації.
Виконується на місці та не вимагає додаткової пам’яті.
Недоліки:
Низька ефективність для великих і невпорядкованих масивів (часова складність O(n^2))
Не підходить для дуже великих обсягів даних у порівнянні з більш складними алгоритмами, як-от швидке сортування чи сортування злиттям.

Сортування бульбашкою – найменш ефективний метод, хоча й простий.
Сортування вибором підходить для невеликих обсягів даних, але завжди виконує однаковий обсяг роботи, незалежно від упорядкованості.
Сортування вставкою є більш універсальним серед цих трьох методів, особливо для майже відсортованих даних.

### 2. Оцініть кожен з методів відповідно до наступних критеріїв:
- час роботи;
- потреби у додатковій пам’яті;
- стабільність.
За якими ще критеріями ви можете порівняти ці алгоритми?

Сортування бульбашкою
Час роботи: Найгірший і середній випадки O(n^2), найкращий – O(n) (за наявності оптимізації).
Потреби у додатковій пам’яті: O(1), сортування відбувається на місці.
Стабільність: Стабільний алгоритм, бо не змінює відносного порядку однакових елементів.

Сортування вибором
Час роботи: Завжди O(n^2), незалежно від початкового стану масиву.
Потреби у додатковій пам’яті: O(1), сортування на місці.
Стабільність: Нестабільний алгоритм, бо під час обміну елементи можуть змінювати свій порядок.

Час роботи: Найгірший і середній випадки O(n^2), найкращий – O(n) (коли масив майже відсортований).
Потреби у додатковій пам’яті: O(1), сортування на місці.
Стабільність: Стабільний алгоритм.

Додаткові критерії для порівняння:
Простота реалізації.
Чутливість до початкового стану даних.
Паралелізація.
Використання в реальних задачах (практична ефективність).

### 3. Який випадок є найкращім або найгіршим для роботи цих алгоритмів? (Наприклад: частково відсортований масив або масив, відсортований у зворотному порядку). Який з методів забезпечить у цих випадках найкращій/найгірший результат?
Сортування бульбашкою

Найкращий випадок: Масив майже відсортований (з оптимізацією) – час роботи  O(n)
Найгірший випадок: Масив відсортований у зворотному порядку – час роботи O(n^2)

Сортування вибором
Найкращий і найгірший випадки: Незалежно від початкового стану, час роботи завжди O(n^2)

Сортування вставкою
Найкращий випадок: Масив майже відсортований – час роботи O(n)
Найгірший випадок: Масив відсортований у зворотному порядку – час роботи O(n^2)

Порівняння результатів
У випадку майже відсортованого масиву сортування вставкою найефективніше.
У випадку зворотного порядку всі три алгоритми демонструют O(n^2), але вибір і вставка менш залежні від числа перестановок.

### 4. Що означають позначення O(1), O(n), O(n^2)?
Позначення O (Big-O) використовується для опису асимптотичної складності алгоритмів, тобто оцінки швидкості їх роботи при великих розмірах вхідних даних.
O(1): Час виконання алгоритму постійний, не залежить від розміру вхідних даних (наприклад, доступ до елемента за індексом у масиві).
O(n): Час виконання зростає лінійно із збільшенням кількості вхідних даних (наприклад, лінійний пошук).
O(n^2): Час виконання зростає пропорційно квадрату розміру вхідних даних (наприклад, вкладені цикли для порівняння кожного елемента з кожним іншим).

Ці позначення дозволяють порівнювати ефективність алгоритмів для різних обсягів даних.